import pefile
from datetime import datetime, timezone

def format_size(size):
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size < 1024:
            return f"{size:.2f} {unit}"
        size /= 1024
    return f"{size:.2f} PB"

def format_address(address):
    return f"0x{address:08X}"

def analyze_pe(file_path, progress_signal):
    pe = pefile.PE(file_path)
    
    try:
        pe_info = {
            "dos_header": {},
            "pe_header": {},
            "optional_header": {},
            "sections": [],
            "imports": [],
            "exports": [],
            "resources": [],
            "debug": [],
            "compilation_info": {}
        }

        # DOS Header
        progress_signal.emit(10, "Loading DOS Header...")
        pe_info["dos_header"] = {
            "e_magic": pe.DOS_HEADER.e_magic,
            "e_lfanew": format_address(pe.DOS_HEADER.e_lfanew),
        }

        # PE Header
        progress_signal.emit(20, "Loading PE Header...")
        pe_info["pe_header"] = {
            "signature": hex(pe.NT_HEADERS.Signature),
            "machine": hex(pe.FILE_HEADER.Machine),
            "number_of_sections": pe.FILE_HEADER.NumberOfSections,
            "time_date_stamp": datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp, tz=timezone.utc).strftime('%Y-%m-%d %H:%M:%S %Z'),
            "pointer_to_symbol_table": format_address(pe.FILE_HEADER.PointerToSymbolTable),
            "number_of_symbols": pe.FILE_HEADER.NumberOfSymbols,
            "size_of_optional_header": format_size(pe.FILE_HEADER.SizeOfOptionalHeader),
            "characteristics": hex(pe.FILE_HEADER.Characteristics),
        }

        # Optional Header
        progress_signal.emit(30, "Loading Optional Header...")
        pe_info["optional_header"] = {
            "magic": hex(pe.OPTIONAL_HEADER.Magic),
            "subsystem": pefile.SUBSYSTEM_TYPE[pe.OPTIONAL_HEADER.Subsystem],
            "entry_point": format_address(pe.OPTIONAL_HEADER.AddressOfEntryPoint),
            "image_base": format_address(pe.OPTIONAL_HEADER.ImageBase),
            "section_alignment": format_size(pe.OPTIONAL_HEADER.SectionAlignment),
            "file_alignment": format_size(pe.OPTIONAL_HEADER.FileAlignment),
            "size_of_image": format_size(pe.OPTIONAL_HEADER.SizeOfImage),
            "size_of_headers": format_size(pe.OPTIONAL_HEADER.SizeOfHeaders),
            "checksum": hex(pe.OPTIONAL_HEADER.CheckSum),
            "dll_characteristics": hex(pe.OPTIONAL_HEADER.DllCharacteristics),
            "size_of_stack_reserve": format_size(pe.OPTIONAL_HEADER.SizeOfStackReserve),
            "size_of_stack_commit": format_size(pe.OPTIONAL_HEADER.SizeOfStackCommit),
        }

        # Sections
        progress_signal.emit(40, "Loading Sections...")
        for section in pe.sections:
            pe_info["sections"].append({
                "name": section.Name.decode().strip(),
                "virtual_size": format_size(section.Misc_VirtualSize),
                "virtual_address": format_address(section.VirtualAddress),
                "size_of_raw_data": format_size(section.SizeOfRawData),
                "pointer_to_raw_data": format_address(section.PointerToRawData),
                "characteristics": hex(section.Characteristics),
            })

        # Imports
        progress_signal.emit(50, "Loading Imports...")
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_info = {
                    "dll": entry.dll.decode(),
                    "functions": []
                }
                for imp in entry.imports:
                    dll_info["functions"].append({
                        "name": imp.name.decode() if imp.name else '',
                        "address": format_address(imp.address)
                    })
                pe_info["imports"].append(dll_info)

        # Exports
        progress_signal.emit(60, "Loading Exports...")
        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                pe_info["exports"].append({
                    "name": exp.name.decode() if exp.name else '',
                    "address": format_address(pe.OPTIONAL_HEADER.ImageBase + exp.address)
                })

        # Resources
        progress_signal.emit(70, "Loading Resources...")
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                pe_info["resources"].append({
                    "type": resource_type.name if resource_type.name else resource_type.struct.Id
                })

        # Debug
        progress_signal.emit(80, "Loading Debug Information...")
        if hasattr(pe, 'DIRECTORY_ENTRY_DEBUG'):
            for debug in pe.DIRECTORY_ENTRY_DEBUG:
                pe_info["debug"].append({
                    "type": debug.struct.Type,
                    "size": format_size(debug.struct.SizeOfData)
                })

        # Compilation Info
        progress_signal.emit(90, "Loading Compilation Info...")
        compile_time = datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp, tz=timezone.utc).strftime('%Y-%m-%d %H:%M:%S %Z')
        pe_info["compilation_info"] = {
            "compile_time": compile_time,
            "compiler_stamp": hex(pe.OPTIONAL_HEADER.Magic)
        }

    finally:
        pe.close()
        progress_signal.emit(100, "Analysis Complete")

    return pe_info
