# views/full_scan_widget.py

import os
import pandas as pd
import numpy as np
import pickle
from ml_related_files.feature_extract import extract_infos
from tensorflow.keras.models import load_model
from scipy.stats import mode
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QPushButton, QLabel, QProgressBar, QTableWidget, QTableWidgetItem, QHeaderView, QScrollArea, QSizePolicy, QMessageBox
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from PyQt5.QtGui import QFont
import warnings
from file_info import get_file_info
import time

warnings.filterwarnings("ignore", category=UserWarning)

class ScanThread(QThread):
    progress_signal = pyqtSignal(int, str)
    result_signal = pyqtSignal(list)
    error_signal = pyqtSignal(str)

    def __init__(self, exe_files, models_ml, models_nn, columns):
        super().__init__()
        self.exe_files = exe_files
        self.models_ml = models_ml
        self.models_nn = models_nn
        self.columns = columns

    def hard_voting_ensemble(self, models_ml, data_ml, models_nn, data_nn):
        predictions_ml = [model.predict(data_ml) for model in models_ml]
        predictions_nn = [np.argmax(model.predict(data_nn), axis=-1) for model in models_nn]
        all_predictions = np.array(predictions_ml + predictions_nn)
        all_predictions_transposed = np.transpose(all_predictions)
        final_predictions, _ = mode(all_predictions_transposed, axis=1)
        return final_predictions.flatten()

    def run(self):
        results = []
        total_files = len(self.exe_files)
        start_time = time.time()

        for i, exe_file in enumerate(self.exe_files):
            full_path = exe_file['path']
            self.progress_signal.emit(int((i / total_files) * 100), f"Scanning: {full_path}...")
            try:
                data = extract_infos(full_path)
            except Exception as e:
                self.error_signal.emit(f"Error scanning {full_path}: {str(e)}")
                continue

            df = pd.DataFrame([data], columns=self.columns)
            final_predictions = self.hard_voting_ensemble(
                models_ml=self.models_ml,
                data_ml=df,
                models_nn=self.models_nn,
                data_nn=df
            )
            prediction = "legitimate" if final_predictions[0] == 1 else "malicious"
            file_info = get_file_info(full_path)
            results.append({'file': exe_file['name'], 'prediction': prediction, 'metadata': file_info})

            elapsed_time = time.time() - start_time
            estimated_total_time = (elapsed_time / (i + 1)) * total_files
            remaining_time = estimated_total_time - elapsed_time
            self.progress_signal.emit(int((i / total_files) * 100), f"Scanning: {full_path}... Estimated time remaining: {int(remaining_time)} seconds")

        self.result_signal.emit(results)

class FullScanWidget(QWidget):
    def __init__(self, parent=None):
        super(FullScanWidget, self).__init__(parent)

        self.layout = QVBoxLayout()

        self.start_button = QPushButton("Start Full Scan")
        self.start_button.clicked.connect(self.start_full_scan)
        self.layout.addWidget(self.start_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)
        self.layout.addWidget(self.progress_bar)

        self.progress_label = QLabel("")
        self.layout.addWidget(self.progress_label)

        self.results_label = QLabel("Scan Results:")
        self.layout.addWidget(self.results_label)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)

        self.setLayout(self.layout)

        models_directory = 'D:\\SEMESTER-IX\\Malware Analysis\\malware-detector-v1.0\\ml_related_files\\models\\'
        self.ml_model_files = [f for f in os.listdir(models_directory) if f.endswith('.pkl')]
        self.nn_model_files = [f for f in os.listdir(models_directory) if f.endswith('.h5')]

        self.ml_models = [self.load_ml_model(models_directory + model_file) for model_file in self.ml_model_files]
        self.nn_models = [self.load_keras_model(models_directory + model_file) for model_file in self.nn_model_files]

    def load_ml_model(self, path):
        with open(path, 'rb') as file:
            return pickle.load(file)

    def load_keras_model(self, path):
        return load_model(path)

    def start_full_scan(self):
        root_directory = 'C:\\'  # Root directory for full scan
        self.scan_directory(root_directory)

    def scan_directory(self, directory):
        exe_files = [{'path': os.path.join(root, file), 'name': file}
                     for root, _, files in os.walk(directory) 
                     for file in files if file.endswith('.exe')]
        columns = [
            'Characteristics', 'MajorLinkerVersion', 'SizeOfCode', 'SizeOfInitializedData', 'SizeOfUninitializedData',
            'AddressOfEntryPoint', 'BaseOfCode', 'BaseOfData', 'ImageBase', 'FileAlignment', 'MajorOperatingSystemVersion',
            'MajorImageVersion', 'MinorImageVersion', 'MajorSubsystemVersion', 'SizeOfImage', 'SizeOfHeaders', 'CheckSum',
            'DllCharacteristics', 'SectionsNb', 'SectionsMeanEntropy', 'SectionsMinEntropy', 'SectionsMaxEntropy',
            'SectionsMeanRawsize', 'SectionsMinRawsize', 'SectionsMaxRawsize', 'SectionsMeanVirtualsize',
            'SectionsMinVirtualsize', 'SectionMaxVirtualsize', 'ImportsNbDLL', 'ImportsNb', 'ImportsNbOrdinal', 'ExportNb',
            'ResourcesNb', 'ResourcesMeanEntropy', 'ResourcesMinEntropy', 'ResourcesMaxEntropy', 'ResourcesMeanSize',
            'ResourcesMinSize', 'ResourcesMaxSize', 'LoadConfigurationSize', 'VersionInformationSize'
        ]

        self.progress_bar.setVisible(True)
        self.scan_thread = ScanThread(exe_files, self.ml_models, self.nn_models, columns)
        self.scan_thread.progress_signal.connect(self.update_progress)
        self.scan_thread.result_signal.connect(self.display_results)
        self.scan_thread.error_signal.connect(self.show_error)
        self.scan_thread.start()

    def update_progress(self, value, message):
        self.progress_bar.setValue(value)
        self.progress_label.setText(message)

    def display_results(self, results):
        self.clear_layout(self.scroll_layout)

        for result in results:
            file_label = QLabel(f"File: {result['file']} - Prediction: {result['prediction']}")
            file_label.setStyleSheet("font-weight: bold; font-size: 30px; margin-top: 20px;")
            self.scroll_layout.addWidget(file_label)

            table_widget = QTableWidget()
            table_widget.setColumnCount(2)
            table_widget.setHorizontalHeaderLabels(['Field', 'Value'])
            table_widget.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
            table_widget.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
            table_widget.horizontalHeader().setStretchLastSection(True)
            table_widget.setStyleSheet("""
                QTableWidget {
                    font-size: 12pt;
                } 
                QHeaderView::section {
                    font-size: 14pt;
                }
            """)
            table_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

            def add_row(field, value):
                row_position = table_widget.rowCount()
                table_widget.insertRow(row_position)
                table_widget.setItem(row_position, 0, QTableWidgetItem(field))
                table_widget.setItem(row_position, 1, QTableWidgetItem(value))

            def add_header(title):
                row_position = table_widget.rowCount()
                table_widget.insertRow(row_position)
                item = QTableWidgetItem(title)
                item.setTextAlignment(Qt.AlignCenter)
                item.setFont(QFont('Arial', 14, QFont.Bold))
                table_widget.setSpan(row_position, 0, 1, 2)
                table_widget.setItem(row_position, 0, item)

            add_header("Hashes")
            for algo, hash_value in result['metadata']['hashes'].items():
                add_row(algo.upper(), hash_value)

            add_header("Metadata")
            for key, value in result['metadata']['metadata'].items():
                add_row(key, str(value))

            table_widget.setFixedHeight(table_widget.verticalHeader().length() + table_widget.horizontalHeader().height())
            table_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            table_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.scroll_layout.addWidget(table_widget)

        self.update_progress(100, 'Scan completed.')

    def show_error(self, message):
        QMessageBox.warning(self, "Scan Error", message)

    def clear_layout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
