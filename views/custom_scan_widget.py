import os
import pandas as pd
import numpy as np
import pickle
from ml_related_files.feature_extract import extract_infos
from tensorflow.keras.models import load_model
from scipy.stats import mode
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QFileDialog, QLabel,
    QProgressBar, QScrollArea, QTableWidget, QTableWidgetItem,
    QSizePolicy, QMessageBox, QHeaderView
)
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from PyQt5.QtGui import QFont
import warnings
from file_info import get_file_info
from pefile import PEFormatError

warnings.filterwarnings("ignore", category=UserWarning)


class ScanThread(QThread):
    progress_signal = pyqtSignal(int, str)
    result_signal = pyqtSignal(list)

    def __init__(self, exe_files, models_ml, models_nn, columns):
        super().__init__()
        self.exe_files = exe_files
        self.models_ml = models_ml
        self.models_nn = models_nn
        self.columns = columns

    def hard_voting_ensemble(self, models_ml, data_ml, models_nn, data_nn):
        predictions_ml = [model.predict(data_ml) for model in self.models_ml]
        predictions_nn = [np.argmax(model.predict(data_nn), axis=-1) for model in self.models_nn]
        all_predictions = np.array(predictions_ml + predictions_nn)
        all_predictions_transposed = np.transpose(all_predictions)
        final_predictions, _ = mode(all_predictions_transposed, axis=1)
        return final_predictions.flatten()

    def run(self):
        results = []
        total_files = len(self.exe_files)
        for i, exe_file in enumerate(self.exe_files):
            full_path = exe_file['path']
            self.progress_signal.emit(int((i / total_files) * 100), f"Scanning: {full_path}...")
            try:
                data = extract_infos(full_path)
                df = pd.DataFrame([data], columns=self.columns)
                final_predictions = self.hard_voting_ensemble(
                    models_ml=self.models_ml,
                    data_ml=df,
                    models_nn=self.models_nn,
                    data_nn=df
                )
                prediction = "legitimate" if final_predictions[0] == 1 else "malicious"
                file_info = get_file_info(full_path)
                results.append({'file': exe_file['name'], 'prediction': prediction, 'metadata': file_info})
            except PEFormatError as e:
                print(f"Error processing file {full_path}: {e}")
                results.append({'file': exe_file['name'], 'prediction': 'Invalid PE File', 'metadata': {}})
            except Exception as e:
                print(f"An unexpected error occurred while processing {full_path}: {e}")
                results.append({'file': exe_file['name'], 'prediction': 'Error', 'metadata': {}})
        self.result_signal.emit(results)


class CustomScanWidget(QWidget):
    scan_completed = pyqtSignal(list)  # Signal emitted when scan is completed

    def __init__(self, parent=None):
        super(CustomScanWidget, self).__init__(parent)

        self.layout = QVBoxLayout()

        self.select_button = QPushButton("Select Directory to Scan")
        self.select_button.clicked.connect(self.select_directory)
        self.layout.addWidget(self.select_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)
        self.layout.addWidget(self.progress_bar)

        self.progress_label = QLabel("")
        self.layout.addWidget(self.progress_label)

        self.results_label = QLabel("Scan Results:")
        self.layout.addWidget(self.results_label)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)

        self.setLayout(self.layout)

        models_directory = 'ml_related_files/models/'
        self.ml_model_files = [f for f in os.listdir(models_directory) if f.endswith('.pkl')]
        self.nn_model_files = [f for f in os.listdir(models_directory) if f.endswith('.h5')]

        self.ml_models = [self.load_ml_model(os.path.join(models_directory, model_file)) for model_file in self.ml_model_files]
        self.nn_models = [self.load_keras_model(os.path.join(models_directory, model_file)) for model_file in self.nn_model_files]

    def load_ml_model(self, path):
        with open(path, 'rb') as file:
            return pickle.load(file)

    def load_keras_model(self, path):
        return load_model(path)

    def select_directory(self):
        dir_dialog = QFileDialog.getExistingDirectory(self, 'Select Directory')
        if dir_dialog:
            self.scan_directory(dir_dialog)

    def scan_directory(self, directory):
        exe_files = []
        for root, dirs, files in os.walk(directory):
            for f in files:
                if f.lower().endswith('.exe'):
                    full_path = os.path.join(root, f)
                    exe_files.append({'path': full_path, 'name': f})

        if not exe_files:
            QMessageBox.information(self, "No Executables Found", "No executable files found in the selected directory.")
            return

        columns = [
            'Characteristics', 'MajorLinkerVersion', 'SizeOfCode', 'SizeOfInitializedData', 'SizeOfUninitializedData',
            'AddressOfEntryPoint', 'BaseOfCode', 'BaseOfData', 'ImageBase', 'FileAlignment', 'MajorOperatingSystemVersion',
            'MajorImageVersion', 'MinorImageVersion', 'MajorSubsystemVersion', 'SizeOfImage', 'SizeOfHeaders', 'CheckSum',
            'DllCharacteristics', 'SectionsNb', 'SectionsMeanEntropy', 'SectionsMinEntropy', 'SectionsMaxEntropy',
            'SectionsMeanRawsize', 'SectionsMinRawsize', 'SectionsMaxRawsize', 'SectionsMeanVirtualsize',
            'SectionsMinVirtualsize', 'SectionMaxVirtualsize', 'ImportsNbDLL', 'ImportsNb', 'ImportsNbOrdinal', 'ExportNb',
            'ResourcesNb', 'ResourcesMeanEntropy', 'ResourcesMinEntropy', 'ResourcesMaxEntropy', 'ResourcesMeanSize',
            'ResourcesMinSize', 'ResourcesMaxSize', 'LoadConfigurationSize', 'VersionInformationSize'
        ]

        self.progress_bar.setVisible(True)
        self.scan_thread = ScanThread(exe_files, self.ml_models, self.nn_models, columns)
        self.scan_thread.progress_signal.connect(self.update_progress)
        self.scan_thread.result_signal.connect(self.display_results)
        self.scan_thread.start()

    def update_progress(self, value, message):
        self.progress_bar.setValue(value)
        self.progress_label.setText(message)

    def display_results(self, results):
        self.clear_layout(self.scroll_layout)

        for result in results:
            prediction = result['prediction']
            file_label = QLabel(f"File: {result['file']} - Prediction: {prediction}")
            file_label.setStyleSheet("font-weight: bold; font-size: 18px; margin-top: 20px;")
            self.scroll_layout.addWidget(file_label)

            if prediction in ['Invalid PE File', 'Error']:
                error_label = QLabel("The file could not be processed.")
                error_label.setStyleSheet("color: red;")
                self.scroll_layout.addWidget(error_label)
                continue  # Skip displaying metadata for invalid files

            table_widget = QTableWidget()
            table_widget.setColumnCount(2)
            table_widget.setHorizontalHeaderLabels(['Field', 'Value'])
            table_widget.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
            table_widget.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
            table_widget.horizontalHeader().setStretchLastSection(True)
            table_widget.setStyleSheet("""
                QTableWidget {
                    font-size: 12pt;
                } 
                QHeaderView::section {
                    font-size: 14pt;
                }
            """)
            table_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

            def add_row(field, value):
                row_position = table_widget.rowCount()
                table_widget.insertRow(row_position)
                table_widget.setItem(row_position, 0, QTableWidgetItem(field))
                table_widget.setItem(row_position, 1, QTableWidgetItem(value))

            def add_header(title):
                row_position = table_widget.rowCount()
                table_widget.insertRow(row_position)
                item = QTableWidgetItem(title)
                item.setTextAlignment(Qt.AlignCenter)
                item.setFont(QFont('Arial', 14, QFont.Bold))
                table_widget.setSpan(row_position, 0, 1, 2)
                table_widget.setItem(row_position, 0, item)

            add_header("Hashes")
            for algo, hash_value in result['metadata'].get('hashes', {}).items():
                add_row(algo.upper(), hash_value)

            add_header("Metadata")
            for key, value in result['metadata'].get('metadata', {}).items():
                add_row(key, str(value))

            table_widget.setFixedHeight(table_widget.verticalHeader().length() + table_widget.horizontalHeader().height())
            table_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            table_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.scroll_layout.addWidget(table_widget)

        self.update_progress(100, 'Scan completed.')
        self.scan_completed.emit(results)  # Emit the signal with the scan results

    def clear_layout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
