# views/custom_scan_widget.py

import os
import pandas as pd
import numpy as np
import pickle
from ml_related_files.feature_extract import extract_infos
from tensorflow.keras.models import load_model
from scipy.stats import mode
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QPushButton, QFileDialog, QTableWidget, QTableWidgetItem, QLabel, QProgressBar, QHeaderView, QScrollArea, QHBoxLayout, QFrame, QSizePolicy
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from PyQt5.QtGui import QFont
import warnings
from file_info import get_file_info

warnings.filterwarnings("ignore", category=UserWarning)

class ScanThread(QThread):
    progress_signal = pyqtSignal(int, str)
    result_signal = pyqtSignal(list)

    def __init__(self, exe_files, models_ml, models_nn, columns):
        super().__init__()
        self.exe_files = exe_files
        self.models_ml = models_ml
        self.models_nn = models_nn
        self.columns = columns

    def hard_voting_ensemble(self, models_ml, data_ml, models_nn, data_nn):
        predictions_ml = [model.predict(data_ml) for model in models_ml]
        predictions_nn = [np.argmax(model.predict(data_nn), axis=-1) for model in models_nn]
        all_predictions = np.array(predictions_ml + predictions_nn)
        all_predictions_transposed = np.transpose(all_predictions)
        final_predictions, _ = mode(all_predictions_transposed, axis=1)
        return final_predictions.flatten()

    def run(self):
        results = []
        total_files = len(self.exe_files)
        for i, exe_file in enumerate(self.exe_files):
            full_path = exe_file['path']
            self.progress_signal.emit(int((i / total_files) * 100), f"Scanning: {full_path}...")
            data = extract_infos(full_path)
            df = pd.DataFrame([data], columns=self.columns)
            final_predictions = self.hard_voting_ensemble(
                models_ml=self.models_ml,
                data_ml=df,
                models_nn=self.models_nn,
                data_nn=df
            )
            prediction = "legitimate" if final_predictions[0] == 1 else "malicious"
            file_info = get_file_info(full_path)
            results.append({'file': exe_file['name'], 'prediction': prediction, 'metadata': file_info})
        self.result_signal.emit(results)

class CustomScanWidget(QWidget):
    def __init__(self, parent=None):
        super(CustomScanWidget, self).__init__(parent)

        self.layout = QVBoxLayout()

        self.select_button = QPushButton("Select Directory to Scan")
        self.select_button.clicked.connect(self.select_directory)
        self.layout.addWidget(self.select_button)

        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)
        self.layout.addWidget(self.progress_bar)

        self.progress_label = QLabel("")
        self.layout.addWidget(self.progress_label)

        self.results_label = QLabel("Scan Results:")
        self.layout.addWidget(self.results_label)

        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)

        self.setLayout(self.layout)

        models_directory = 'D:\\SEMESTER-IX\\Malware Analysis\\malware-detector-v1.0\\ml_related_files\\models\\'
        self.ml_model_files = [f for f in os.listdir(models_directory) if f.endswith('.pkl')]
        self.nn_model_files = [f for f in os.listdir(models_directory) if f.endswith('.h5')]

        self.ml_models = [self.load_ml_model(models_directory + model_file) for model_file in self.ml_model_files]
        self.nn_models = [self.load_keras_model(models_directory + model_file) for model_file in self.nn_model_files]

    def load_ml_model(self, path):
        with open(path, 'rb') as file:
            return pickle.load(file)

    def load_keras_model(self, path):
        return load_model(path)

    def select_directory(self):
        dir_dialog = QFileDialog.getExistingDirectory(self, 'Select Directory')
        if dir_dialog:
            self.scan_directory(dir_dialog)

    def scan_directory(self, directory):
        exe_files = [{'path': os.path.join(directory, f), 'name': f} for f in os.listdir(directory) if f.endswith('.exe')]
        columns = [
            'Characteristics', 'MajorLinkerVersion', 'SizeOfCode', 'SizeOfInitializedData', 'SizeOfUninitializedData',
            'AddressOfEntryPoint', 'BaseOfCode', 'BaseOfData', 'ImageBase', 'FileAlignment', 'MajorOperatingSystemVersion',
            'MajorImageVersion', 'MinorImageVersion', 'MajorSubsystemVersion', 'SizeOfImage', 'SizeOfHeaders', 'CheckSum',
            'DllCharacteristics', 'SectionsNb', 'SectionsMeanEntropy', 'SectionsMinEntropy', 'SectionsMaxEntropy',
            'SectionsMeanRawsize', 'SectionsMinRawsize', 'SectionsMaxRawsize', 'SectionsMeanVirtualsize',
            'SectionsMinVirtualsize', 'SectionMaxVirtualsize', 'ImportsNbDLL', 'ImportsNb', 'ImportsNbOrdinal', 'ExportNb',
            'ResourcesNb', 'ResourcesMeanEntropy', 'ResourcesMinEntropy', 'ResourcesMaxEntropy', 'ResourcesMeanSize',
            'ResourcesMinSize', 'ResourcesMaxSize', 'LoadConfigurationSize', 'VersionInformationSize'
        ]

        self.progress_bar.setVisible(True)
        self.scan_thread = ScanThread(exe_files, self.ml_models, self.nn_models, columns)
        self.scan_thread.progress_signal.connect(self.update_progress)
        self.scan_thread.result_signal.connect(self.display_results)
        self.scan_thread.start()

    def update_progress(self, value, message):
        self.progress_bar.setValue(value)
        self.progress_label.setText(message)

    def display_results(self, results):
        self.clear_layout(self.scroll_layout)

        for result in results:
            file_label = QLabel(f"File: {result['file']} - Prediction: {result['prediction']}")
            file_label.setStyleSheet("font-weight: bold; font-size: 30px; margin-top: 20px;")
            self.scroll_layout.addWidget(file_label)

            table_widget = QTableWidget()
            table_widget.setColumnCount(2)
            table_widget.setHorizontalHeaderLabels(['Field', 'Value'])
            table_widget.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
            table_widget.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
            table_widget.horizontalHeader().setStretchLastSection(True)
            table_widget.setStyleSheet("""
                QTableWidget {
                    font-size: 12pt;
                } 
                QHeaderView::section {
                    font-size: 14pt;
                }
            """)
            table_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

            def add_row(field, value):
                row_position = table_widget.rowCount()
                table_widget.insertRow(row_position)
                table_widget.setItem(row_position, 0, QTableWidgetItem(field))
                table_widget.setItem(row_position, 1, QTableWidgetItem(value))

            def add_header(title):
                row_position = table_widget.rowCount()
                table_widget.insertRow(row_position)
                item = QTableWidgetItem(title)
                item.setTextAlignment(Qt.AlignCenter)
                item.setFont(QFont('Arial', 14, QFont.Bold))
                table_widget.setSpan(row_position, 0, 1, 2)
                table_widget.setItem(row_position, 0, item)

            add_header("Hashes")
            for algo, hash_value in result['metadata']['hashes'].items():
                add_row(algo.upper(), hash_value)

            add_header("Metadata")
            for key, value in result['metadata']['metadata'].items():
                add_row(key, str(value))

            table_widget.setFixedHeight(table_widget.verticalHeader().length() + table_widget.horizontalHeader().height())
            table_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            table_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.scroll_layout.addWidget(table_widget)

        # self.progress_label.setText("Scan completed.")
        self.update_progress(100, 'Scan completed.')

    def clear_layout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
